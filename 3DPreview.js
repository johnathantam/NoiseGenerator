// PREFACE
//
// Noise maps are most commonly used for terrain generation, so I figured I have
// to add a 3D preview of the noise map generated by the user
//
// A bit about the workflow of this file:
//
// It is completely independant, this file works seperatedly from the 
// NoiseMapGeneration.js file. So when reading this, keep in mind that
// no information is transffered between the files. So read locally and 
// without burden. 
//
// This file commonly references a variable called THREE from three.js, 
// but THREE is not declared anywhere in this script. It is declared in a 
// cdn called by a script file in the html. So hopefully that clears some confusion
//
// TL;DR: This file handles the 3D preview of the noise map

// initialize scene variables with three.js

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,0.1,1000 );
const renderer = new THREE.WebGLRenderer({ 
  canvas: document.getElementById('noise-canvas-3d'),
});

// initialize framerate settings

const clock = new THREE.Clock();
const interval = 1 / 18; // 18 frames per second
let delta = 0; // time between frames - similar to Time.deltaTime in unity

// initialize objects within the scene needed

let plane = null; 

// this function sets the lighting and camera of the scene

function initializeScene() {

  // set default cam position
  camera.position.set(0,-14,30);

  // add light to the scene
  const ambientLight = new THREE.AmbientLight( 0xfffffff, 2.2 );
  
  scene.add(ambientLight);
  
  renderer.render( scene, camera );
  
}

// this function creates a pre rendered noise map as a example for the user to see

function initializeNoiseAs3DModel() {

  const geometry = new THREE.PlaneGeometry( 25, 25, 20, 20 );
  const material = new THREE.MeshStandardMaterial( {
    color: "gray", 
    map:  new THREE.TextureLoader().load('./Images/blurry-gradient-haikei.png'),
		displacementMap: new THREE.TextureLoader().load('./Images/initial.jpg'), // load noise map
		displacementScale: 5,
  } );

	plane = new THREE.Mesh( geometry, material );

	plane.rotation.set(-70, 0, 0);
	plane.position.set(0, -11, 0);

	scene.add(plane);
  
}

// this function is where all the magic happens. It is called whenever a new noise map is
// generated. Heres how it works
//
// Once a noise map has been generated, we grab it from the canvas element and convert it
// to a jpg (our noise map). Then we simply apply it as a noise map for a plane, and 
// we have a 3D noise map!

function update3DNoiseMapWithGeneratedNoiseMap() {

  // get noise map and convert to jpg image
  const newNoiseMap = document.getElementById("noise-canvas").toDataURL("image.jpg");

  // destroy previous plane as we are adding a new one
  plane.geometry.dispose();
  scene.remove(plane);

  //generate new plane with the new noise map
  
  const geometry = new THREE.PlaneGeometry( 25, 25, 20, 20 );
  const material = new THREE.MeshStandardMaterial( {
    color: "gray", 
    map:  new THREE.TextureLoader().load(newNoiseMap),
		displacementMap: new THREE.TextureLoader().load(newNoiseMap), // load new noise map
		displacementScale: 6,
  } );

  plane = new THREE.Mesh( geometry, material );

  plane.rotation.set(-70, 0, 0);
	plane.position.set(0, -11, 0);

  scene.add(plane);
  
}

// This function handles the frames of the 3D preview. It is called every frame.
// It is in charge of rendering every new frame and animation. 

function animate() {
  
  requestAnimationFrame( animate );

  //add time between frames, same as Time.deltaTime in unity
  delta += clock.getDelta();

  //see if time fits into our frame intervals (18 fps) and if so then run.
  if (delta  > interval) {

    // rotate the 3D noise map and render the rotated object
    plane.rotation.z += 0.01;
    renderer.render( scene, camera );
    delta = delta % interval;
    
  }
  
};

// call the initialize functions to start the scene and start animating

initializeScene();
initializeNoiseAs3DModel();
animate();